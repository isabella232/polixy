syntax = "proto3";

package polixy.olix0r.net;

import "google/protobuf/duration.proto";

service ProxyConfigService {
  rpc WatchInbound(InboundProxyPort) returns (stream InboundProxyConfig) {}
}

message InboundProxyPort {
  // Identifies a proxy workload (e.g., pod name).
  string workload = 1;

  // An inbound port on _workload_.
  uint32 port = 2;
}

message InboundProxyConfig {
  // If set, indicates how the proxy should proxy connections on the specified
  // port.
  ProxyProtocol protocol = 1;

  // Configures a proxy to allow connections from the specified clients.
  //
  // If unset, no connections are permitted.
  repeated Authz authorizations = 2;

  // Descriptive labels to be added to metrics, etc.
  //
  // A control plane SHOULD return the same keys in all policies. That is, we do
  // NOT want to return arbitrary pod labels in this field.
  map<string, string> labels = 3;
}

message ProxyProtocol {
  oneof kind {
    Detect detect = 1;
    Opaque opaque = 2;
    Http http = 3;
    Grpc grpc = 4;
  }

  message Detect { google.protobuf.Duration timeout = 1; }

  message Opaque {
    // TODO: opaque TLS settings (versions, algorithms, SNI)
  }

  message Http {
    // TODO: domains -> routes -> policy
    // TODO: HTTP version? (and orig-proto upgrades)?
  }

  message Grpc {
    // TODO: service -> endpoint -> policy
  }
}

message Authz {
  // Limits this authorization to client addresses in the provided networks.
  //
  // Must have at least one network, otherwise the authorization must be
  // ignored. An authorization matches all clients by including an explicit
  // match on, i.e., `[0.0.0.0/0, 0::/0]``.
  repeated Network networks = 1;

  // Must be set.
  Authn authentication = 2;

  // Descriptive labels to be added to metrics, etc.
  //
  // A control plane SHOULD return the same keys in all authorizations. That is,
  // we do NOT want to return arbitrary pod labels in this field.
  map<string, string> labels = 3;
}

message Authn {
  oneof permit {
    PermitUnauthenticated unauthenticated = 1;

    // If set, requires that the connection is mutually-authetnicated with a
    // matching client identity.
    PermitProxyIdentities proxy_identities = 2;
  }

  message PermitUnauthenticated {}

  // Matches identities.
  //
  // To match all identities, a suffix i
  message PermitProxyIdentities {
    // A list of literal identities.
    repeated Identity identities = 1;

    // A list of identity suffixes.
    //
    // If this contains an empty suffix, all identities are matched.
    repeated Suffix suffixes = 2;
  }
}

message Identity { string name = 1; }

// Encodes a DNS-like name suffix as sequence of parts.
//
// An empty list is equivalent to `.` (matching all names); the list `["foo",
// "bar"]` is equivalent to "foo.bar." (matching `*.foo.bar`), etc.
message Suffix { repeated string parts = 1; }

// Describes a network in CIDR-notation.
//
// TODO use numeric types rather than a string.
message Network { string cidr = 1; }
